package io.github.hengxin.distributed_mobile_memo.pc.analysis.quantification.quantifyrwn;

import org.apache.commons.lang3.time.DurationFormatUtils;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import io.github.hengxin.distributed_mobile_memo.benchmark.workload.RequestRecord;
import io.github.hengxin.distributed_mobile_memo.pc.PCConstants;
import io.github.hengxin.distributed_mobile_memo.pc.analysis.execution.Execution;
import io.github.hengxin.distributed_mobile_memo.pc.analysis.execution.ExecutionLogHandler;

/**
 * Quantifying executions generated by the RWN (R + W <= N) protocol
 * for eventual consistency against atomicity.
 *
 * @See <a href = "https://github.com/hengxin/distributed-mobile-memo/wiki/Offline-Analysis#quantifying-rwn
 * -executions-quantifyingrwn">Quantifying RWN Executions @ wiki of this project on GitHub</a>.
 *
 * Created by hengxin on 16-3-9.
 */
public class QuantifyingRWN {

    private StalenessViolationMap violation_map = new StalenessViolationMap();

    /**
     * Quantify RWN execution stored in file of {@code path} with respect to atomicity.
     * @param path path of file that contains RWN execution to quantify
     * @return a violation map which associates each k-overwritten anomaly with the number of times it occurs.
     *
     * @See <a href = "https://github.com/hengxin/distributed-mobile-memo/wiki/Offline-Analysis#quantifying-rwn
     * -executions-quantifyingrwn">Quantifying RWN Executions @ wiki of this project on GitHub</a>.
     */
    public void quantify(String path) {
        Execution rwn_execution = new Execution(new ExecutionLogHandler(path).loadRequestRecords());

        List<RequestRecord> write_rr_list = rwn_execution.getWriteRequestRecordList();
        Collections.sort(write_rr_list);

        List<RequestRecord> read_rr_list = rwn_execution.getReadRequestRecordList();
        Collections.sort(read_rr_list);

        Map<RequestRecord, Integer> read_position_map = new HashMap<>(read_rr_list.size());

        for (RequestRecord read_rr : read_rr_list) {
            int write_rr_index = -1;
            int read_from_write_index = -1;
            int first_non_preceding_write_index = -1;

            int read_position = -1;

            Iterator<RequestRecord> write_rr_iter = write_rr_list.iterator();
            RequestRecord write_rr;
            while (write_rr_iter.hasNext()) {
                write_rr = write_rr_iter.next();
                write_rr_index++;

                // "== -1" to ensure uniqueness
                if (read_from_write_index == -1 && read_rr.getVersion().equals(write_rr.getVersion()))
                    read_from_write_index = write_rr_index;

                if (first_non_preceding_write_index == -1) {
                    if (write_rr.getFinishTime() > read_rr.getStartTime())
                        first_non_preceding_write_index = write_rr_index;
                    else if (! write_rr_iter.hasNext()) // edge case: all {@code write_rr} precede {@code read_rr}
                        first_non_preceding_write_index = write_rr_index + 1;
                }

                if (read_from_write_index != -1 && first_non_preceding_write_index != -1) {
                    read_position = Math.max(read_from_write_index + 1, first_non_preceding_write_index);
                    break;
                }
            }

            // {@code read_rr} should be positioned in the {@code write_rr_list} after all its preceding reads.
            int max_preceding_reads_position = -1;
            for (RequestRecord read : read_rr_list) {
                if (read.precedes(read_rr))
                    max_preceding_reads_position = Math.max(max_preceding_reads_position, read_position_map.get
                            (read));
                // the following {@code read} will not precede {@code read_rr}
                if (read.getStartTime() > read_rr.getStartTime())
                    break;
            }

            read_position = Math.max(read_position, max_preceding_reads_position);
            read_position_map.put(read_rr, read_position);
            this.violation_map.put(read_position - 1 - read_from_write_index, read_rr);
        }
    }

    public StalenessViolationMap getViolationMap() {
        return this.violation_map;
    }

    /**
     * Test {@link QuantifyingRWN}.
     * @param args one argument for path of file that contains the execution to quantify
     * @throws IOException  if the file specified in {@code args} is not found
     * @throws IllegalArgumentException  if the size {@code args} != 1
     */
    public static void main(String[] args) throws IOException {
        if (args.length != 1)
            throw new IllegalArgumentException("Parameter: <path>");
        String path = args[0];

        System.out.println("Quantifying RWN execution ...");
        long start_time = System.currentTimeMillis();
        QuantifyingRWN quantifier = new QuantifyingRWN();
        quantifier.quantify(path);
        long finish_time = System.currentTimeMillis();
        System.out.println("Time is: " + DurationFormatUtils.formatDurationHMS(finish_time - start_time));

        StalenessViolationMap violation_map = quantifier.getViolationMap();
        String staleness_file = new File(path).getParent() + File.separator + PCConstants.STALE_MAP_FILE_PATH;
        violation_map.write2File(staleness_file, true);
        System.out.println("Write StalenessViolationMap into file: " + staleness_file);
    }

}
