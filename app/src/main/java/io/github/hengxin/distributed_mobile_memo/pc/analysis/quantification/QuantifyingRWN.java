package io.github.hengxin.distributed_mobile_memo.pc.analysis.quantification;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;

import org.apache.commons.lang3.time.DurationFormatUtils;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import io.github.hengxin.distributed_mobile_memo.benchmark.workload.RequestRecord;
import io.github.hengxin.distributed_mobile_memo.pc.analysis.execution.Execution;
import io.github.hengxin.distributed_mobile_memo.pc.analysis.execution.ExecutionLogHandler;

/**
 * Quantifying executions generated by the RWN (R + W < N) protocol
 * for eventual consistency against atomicity.
 *
 * @See <a href = "https://github.com/hengxin/distributed-mobile-memo/wiki/Offline-Analysis#quantifying-rwn
 * -executions-quantifyingrwn">Quantifying RWN Executions @ wiki of this project on GitHub</a>.
 *
 * Created by hengxin on 16-3-9.
 */
public class QuantifyingRWN {

    /**
     * Quantify RWN execution stored in file of {@code path} with respect to atomicity.
     * @param path path of file that contains RWN execution to quantify
     * @return a violation map which associates each k-overwritten anomaly with the number of times it occurs.
     *
     * @See <a href = "https://github.com/hengxin/distributed-mobile-memo/wiki/Offline-Analysis#quantifying-rwn
     * -executions-quantifyingrwn">Quantifying RWN Executions @ wiki of this project on GitHub</a>.
     */
    public Multimap<Integer, RequestRecord> quantify(String path) {
        Multimap<Integer, RequestRecord> violation_map = ArrayListMultimap.create();

        Execution rwn_execution = new Execution(new ExecutionLogHandler(path).loadRequestRecords());

        List<RequestRecord> write_rr_list = rwn_execution.getWriteRequestRecordList();
        Collections.sort(write_rr_list);

        List<RequestRecord> read_rr_list = rwn_execution.getReadRequestRecordList();
        Collections.sort(read_rr_list);

        Map<RequestRecord, Integer> read_position_map = new HashMap<>(read_rr_list.size());

        for (RequestRecord read_rr : read_rr_list) {
            int write_rr_index = -1;
            int read_from_write_index = -1;
            int first_non_preceding_write_index = -1;

            int read_position = -1;

            Iterator<RequestRecord> write_rr_iter = write_rr_list.iterator();
            RequestRecord write_rr;
            while (write_rr_iter.hasNext()) {
                write_rr = write_rr_iter.next();
                write_rr_index++;

                // "== -1" to ensure uniqueness
                if (read_from_write_index == -1 && read_rr.getVersion().equals(write_rr.getVersion()))
                    read_from_write_index = write_rr_index;

                if (first_non_preceding_write_index == -1) {
                    if (write_rr.getFinishTime() > read_rr.getStartTime())
                        first_non_preceding_write_index = write_rr_index;
                    else if (! write_rr_iter.hasNext()) // edge case: all {@code write_rr} precede {@code read_rr}
                        first_non_preceding_write_index = write_rr_index + 1;
                }

                if (read_from_write_index != -1 && first_non_preceding_write_index != -1) {
                    read_position = Math.max(read_from_write_index + 1, first_non_preceding_write_index);
                    break;
                }
            }

            // {@code read_rr} should be positioned in the {@code write_rr_list} after all its preceding reads.
            int max_preceding_reads_position = -1;
            for (RequestRecord read : read_rr_list) {
                if (read.precedes(read_rr))
                    max_preceding_reads_position = Math.max(max_preceding_reads_position, read_position_map.get
                            (read));
                // the following {@code read} will not precede {@code read_rr}
                if (read.getStartTime() > read_rr.getStartTime())
                    break;
            }

            read_position = Math.max(read_position, max_preceding_reads_position);
            read_position_map.put(read_rr, read_position);
            violation_map.put(read_position - 1 - read_from_write_index, read_rr);
        }

        return violation_map;
    }

    public static void main(String[] args) {
        if (args.length != 1)
            throw new IllegalArgumentException("Parameter: <path>");

        System.out.println("Quantifying RWN execution ...");
        long start_time = System.currentTimeMillis();
        Multimap<Integer, RequestRecord> violation_map = new QuantifyingRWN().quantify(args[0]);
        long finish_time = System.currentTimeMillis();
        System.out.println("Time is: " + DurationFormatUtils.formatDuration(finish_time - start_time, "HH:mm:ss.S"));

        System.out.println("All read operations checked: " + violation_map.size());
        Map<Integer, Collection<RequestRecord>> violation_k_rr_map = violation_map.asMap();
        for (Map.Entry<Integer, Collection<RequestRecord>> violation_k_rr_entry : violation_k_rr_map.entrySet()) {
            int violations = violation_k_rr_entry.getValue().size();
            System.out.println(violation_k_rr_entry.getKey() + " : " + violations + "; Proportion: "
                    + violations * 1.0 / violation_map.size());
        }
    }
    
}
